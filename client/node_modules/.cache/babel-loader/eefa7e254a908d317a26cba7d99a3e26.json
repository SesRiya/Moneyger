{"ast":null,"code":"var SCClientSocket = require('./scclientsocket');\n\nvar scErrors = require('sc-errors');\n\nvar uuid = require('uuid');\n\nvar InvalidArgumentsError = scErrors.InvalidArgumentsError;\nvar _clients = {};\n\nfunction getMultiplexId(options) {\n  var protocolPrefix = options.secure ? 'https://' : 'http://';\n  var queryString = '';\n\n  if (options.query) {\n    if (typeof options.query === 'string') {\n      queryString = options.query;\n    } else {\n      var queryArray = [];\n      var queryMap = options.query;\n\n      for (var key in queryMap) {\n        if (queryMap.hasOwnProperty(key)) {\n          queryArray.push(key + '=' + queryMap[key]);\n        }\n      }\n\n      if (queryArray.length) {\n        queryString = '?' + queryArray.join('&');\n      }\n    }\n  }\n\n  var host;\n\n  if (options.host) {\n    host = options.host;\n  } else {\n    host = options.hostname + ':' + options.port;\n  }\n\n  return protocolPrefix + host + options.path + queryString;\n}\n\nfunction isUrlSecure() {\n  return global.location && location.protocol === 'https:';\n}\n\nfunction getPort(options, isSecureDefault) {\n  var isSecure = options.secure == null ? isSecureDefault : options.secure;\n  return options.port || (global.location && location.port ? location.port : isSecure ? 443 : 80);\n}\n\nfunction create(options) {\n  var self = this;\n  options = options || {};\n\n  if (options.host && !options.host.match(/[^:]+:\\d{2,5}/)) {\n    throw new InvalidArgumentsError('The host option should include both' + ' the hostname and the port number in the format \"hostname:port\"');\n  }\n\n  if (options.host && options.hostname) {\n    throw new InvalidArgumentsError('The host option should already include' + ' the hostname and the port number in the format \"hostname:port\"' + ' - Because of this, you should never use host and hostname options together');\n  }\n\n  if (options.host && options.port) {\n    throw new InvalidArgumentsError('The host option should already include' + ' the hostname and the port number in the format \"hostname:port\"' + ' - Because of this, you should never use host and port options together');\n  }\n\n  var isSecureDefault = isUrlSecure();\n  var opts = {\n    port: getPort(options, isSecureDefault),\n    hostname: global.location && location.hostname || 'localhost',\n    path: '/socketcluster/',\n    secure: isSecureDefault,\n    autoConnect: true,\n    autoReconnect: true,\n    autoSubscribeOnConnect: true,\n    connectTimeout: 20000,\n    ackTimeout: 10000,\n    timestampRequests: false,\n    timestampParam: 't',\n    authEngine: null,\n    authTokenName: 'socketCluster.authToken',\n    binaryType: 'arraybuffer',\n    multiplex: true,\n    pubSubBatchDuration: null,\n    cloneData: false\n  };\n\n  for (var i in options) {\n    if (options.hasOwnProperty(i)) {\n      opts[i] = options[i];\n    }\n  }\n\n  opts.clientMap = _clients;\n\n  if (opts.multiplex === false) {\n    opts.clientId = uuid.v4();\n    var socket = new SCClientSocket(opts);\n    _clients[opts.clientId] = socket;\n    return socket;\n  }\n\n  opts.clientId = getMultiplexId(opts);\n\n  if (_clients[opts.clientId]) {\n    if (opts.autoConnect) {\n      _clients[opts.clientId].connect();\n    }\n  } else {\n    _clients[opts.clientId] = new SCClientSocket(opts);\n  }\n\n  return _clients[opts.clientId];\n}\n\nfunction destroy(socket) {\n  socket.destroy();\n}\n\nmodule.exports = {\n  create: create,\n  destroy: destroy,\n  clients: _clients\n};","map":{"version":3,"sources":["D:/VIC U/SWEN 504/Moneyger/node_modules/socketcluster-client/lib/factory.js"],"names":["SCClientSocket","require","scErrors","uuid","InvalidArgumentsError","_clients","getMultiplexId","options","protocolPrefix","secure","queryString","query","queryArray","queryMap","key","hasOwnProperty","push","length","join","host","hostname","port","path","isUrlSecure","global","location","protocol","getPort","isSecureDefault","isSecure","create","self","match","opts","autoConnect","autoReconnect","autoSubscribeOnConnect","connectTimeout","ackTimeout","timestampRequests","timestampParam","authEngine","authTokenName","binaryType","multiplex","pubSubBatchDuration","cloneData","i","clientMap","clientId","v4","socket","connect","destroy","module","exports","clients"],"mappings":"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","sourcesContent":["var SCClientSocket = require('./scclientsocket');\nvar scErrors = require('sc-errors');\nvar uuid = require('uuid');\nvar InvalidArgumentsError = scErrors.InvalidArgumentsError;\n\nvar _clients = {};\n\nfunction getMultiplexId(options) {\n  var protocolPrefix = options.secure ? 'https://' : 'http://';\n  var queryString = '';\n  if (options.query) {\n    if (typeof options.query === 'string') {\n      queryString = options.query;\n    } else {\n      var queryArray = [];\n      var queryMap = options.query;\n      for (var key in queryMap) {\n        if (queryMap.hasOwnProperty(key)) {\n          queryArray.push(key + '=' + queryMap[key]);\n        }\n      }\n      if (queryArray.length) {\n        queryString = '?' + queryArray.join('&');\n      }\n    }\n  }\n  var host;\n  if (options.host) {\n    host = options.host;\n  } else {\n    host = options.hostname + ':' + options.port;\n  }\n  return protocolPrefix + host + options.path + queryString;\n}\n\nfunction isUrlSecure() {\n  return global.location && location.protocol === 'https:';\n}\n\nfunction getPort(options, isSecureDefault) {\n  var isSecure = options.secure == null ? isSecureDefault : options.secure;\n  return options.port || (global.location && location.port ? location.port : isSecure ? 443 : 80);\n}\n\nfunction create(options) {\n  var self = this;\n\n  options = options || {};\n\n  if (options.host && !options.host.match(/[^:]+:\\d{2,5}/)) {\n    throw new InvalidArgumentsError('The host option should include both' +\n      ' the hostname and the port number in the format \"hostname:port\"');\n  }\n\n  if (options.host && options.hostname) {\n    throw new InvalidArgumentsError('The host option should already include' +\n      ' the hostname and the port number in the format \"hostname:port\"' +\n      ' - Because of this, you should never use host and hostname options together');\n  }\n\n  if (options.host && options.port) {\n    throw new InvalidArgumentsError('The host option should already include' +\n      ' the hostname and the port number in the format \"hostname:port\"' +\n      ' - Because of this, you should never use host and port options together');\n  }\n\n  var isSecureDefault = isUrlSecure();\n\n  var opts = {\n    port: getPort(options, isSecureDefault),\n    hostname: global.location && location.hostname || 'localhost',\n    path: '/socketcluster/',\n    secure: isSecureDefault,\n    autoConnect: true,\n    autoReconnect: true,\n    autoSubscribeOnConnect: true,\n    connectTimeout: 20000,\n    ackTimeout: 10000,\n    timestampRequests: false,\n    timestampParam: 't',\n    authEngine: null,\n    authTokenName: 'socketCluster.authToken',\n    binaryType: 'arraybuffer',\n    multiplex: true,\n    pubSubBatchDuration: null,\n    cloneData: false\n  };\n  for (var i in options) {\n    if (options.hasOwnProperty(i)) {\n      opts[i] = options[i];\n    }\n  }\n  opts.clientMap = _clients;\n\n  if (opts.multiplex === false) {\n    opts.clientId = uuid.v4();\n    var socket = new SCClientSocket(opts);\n    _clients[opts.clientId] = socket;\n    return socket;\n  }\n  opts.clientId = getMultiplexId(opts);\n\n  if (_clients[opts.clientId]) {\n    if (opts.autoConnect) {\n      _clients[opts.clientId].connect();\n    }\n  } else {\n    _clients[opts.clientId] = new SCClientSocket(opts);\n  }\n  return _clients[opts.clientId];\n}\n\nfunction destroy(socket) {\n  socket.destroy();\n}\n\nmodule.exports = {\n  create: create,\n  destroy: destroy,\n  clients: _clients\n};\n"]},"metadata":{},"sourceType":"script"}